# 1：系统介绍
```````
1.1摘要：本系统是使用SpringBoot开发的高并发限时抢购秒杀系统，除了实现基本的登录、查看商品列表、秒杀、下单等功能，项目中还针对高并发情况实现了系统缓存、降级和限流。
1.2快速开始：
    1：开启redis
    2：开启 ‪D:\安装包\rabbitmq_server-3.7.7\sbin\rabbitmq-server.bat
    3；运行程序
`````````
##2：开发笔记
###开发、压测工具
```
IDEA + navicat + Git + Chrome + JMeter
```
###开发技术
````
前端 ：Bootstrap + jQuery + Thymeleaf

后端 ：SpringBoot + MyBatis + MySQL

中间件技术 : Druid + Redis + RabbitMQ
````
###秒杀优化方向
```
1:将请求尽量拦截在系统上游：数据库访问是瓶颈。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，
几乎所有请求都超时，流量虽大，下单成功的有效流量甚小，通过限流、降级等措施来最大化减少对数据库的访问，从而保护系统。

2:充分利用缓存：秒杀商品是一个典型的读多写少的应用场景，充分利用缓存将大大提高并发量
```
###主要技术点
```
1:两次MD5加密
    好处：
    第一次作用：防止用户明文密码在网络进行传输；
    第二次作用：防止数据库被盗，避免通过MD5反推出密码，双重保险；
2:redis缓存登录用户对象，并使用拦截器通过cookie中的token和redis用户缓存在运行处理器方法前预先得到用户对象
    验证用户账号密码都正确情况下，通过UUID生成唯一id作为token，再将token作为key、用户信息作为value模拟session存储到redis，同时将token存储到cookie，保存登录状态
    好处： 在分布式集群情况下，服务器间需要同步，定时同步各个服务器的session信息，会因为延迟到导致session不一致，使用redis把session数据集中存储起来，解决session不一致问题。
3：使用HandlerMethodArgumentResolver方法解析处理器方法的自定义参数，装载被拦截器预先获得并存放到ThreadLocal当中的对象
4:JSR303自定义参数验证
    使用JSR303自定义校验器，实现对用户账号、密码的验证，使得验证逻辑从业务代码中脱离出来。
5：全局异常统一处理
    通过拦截所有异常，对各种异常进行相应的处理，当遇到异常就逐层上抛，一直抛到最终由一个统一的、专门负责异常处理的地方处理，这有利于对异常的维护。
6：页面缓存 + 对象缓存
    页面缓存：通过在手动渲染得到的html页面缓存到redis
    对象缓存：包括对用户信息、商品信息、订单信息和token等数据进行缓存，利用缓存来减少对数据库的访问，大大加快查询速度。
7：页面静态化
    对商品细节和订单详情进行页面静态化处理，页面是存在html，动态数据是通过ajax从服务端获取后渲染，以此达到前后端分离，
    优点：静态页面无需连接数据库打开速度较动态页面会有明显提高
8. 返回随机路径秒杀参数，使用数学公式验证码
    描述：点击秒杀后，返回随机路径秒杀参数，防止秒杀接口暴露，以避免复制地址链接在浏览器地址栏反复刷，
          让用户输入数学公式验证码，验证正确才能进行秒杀。
    好处：防止秒杀接口暴露
          防止恶意的机器人和爬虫
          分散用户的请求
9：自定义注解控制器实现限流：
    描述：秒杀商品时，可能会因为秒杀点击量太高而导致系统崩溃，此时要使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：返回提示，返回排队页面（高峰期访问太频繁，等一会重试）、错误页等。
    实现1：在拦截器判断处理器方法当中是否有自定义注解AccessLimit，本项目是判断载规定时间内是否到达最大点击次数，没达到则载缓存中对当前url+用户id为键的点击次数值+1，当然该键值对设有生存期，如达到最大点击次数则返回提示信息
10: 商品库存预加载(秒杀前预先把秒杀的商品（重点是库存)加载到redis当中）+判断是否重复购买 +redis商品预减少，判断是否有库存+ RabbitMQ异步下单（返回数据对象代码是成功的） -> 客户端轮询(判断是在排队还是秒杀成功已经生成订单了或者是没货了)
    描述：通过1、商品库存预加载 2、判断是否重复购买 3、redis商品预减少，判断是否有库存 4、RabbitMQ异步下单，
    最后才会访问数据库，这样做是为了最大力度减少对数据库的访问。
11: 解决超卖
     描述：比如某商品的库存为1，此时用户1和用户2并发购买该商品，用户1提交订单后该商品的库存被修改为0，而此时用户2并不知道的情况下提交订单，该商品的库存再次被修改为-1，这就是超卖现象
     实现： 对库存更新时，先对库存判断，只有当库存大于0才能更新库存
 
```
